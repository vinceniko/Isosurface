#pragma kernel SurfacePointsKernel

#include "Common.hlsl"

[numthreads(4, 4, 4)]
void SurfacePointsKernel(uint3 id: SV_DispatchThreadID) {
    float3 pos = id; // cube rooted at pos
    
    Edge cube_edges[12];

    // strides
    const int3 x_stride = int3(1, 0, 0);
    const int3 y_stride = int3(0, 1, 0);
    const int3 z_stride = int3(0, 0, 1);
    int3 dim_offsets[3] = {x_stride, y_stride, z_stride};
    
    // operate on each axis
    for (int i = 0; i < 3; i++) {
        int3 main_dim_offset = dim_offsets[i];

        int other_dims[2];
        for (int dim_i = 0, arr_idx = 0; dim_i < 3; dim_i++) {
            if (dim_i != i) {
                other_dims[arr_idx] = dim_i;
                arr_idx++;
            }
        }

        // edge starts
        Edge dim_edges[4];
        // vertical, horizontal
        for (int j = 0; j < 2; j++) {
            dim_edges[j].start = pos + dim_offsets[other_dims[j]];
        }
        // root
        dim_edges[2].start = pos;
        // diagonal
        float3 diag_offset = float3(0.0, 0.0, 0.0);
        for (int j = 0; j < 2; j++) {
            diag_offset += dim_offsets[other_dims[j]];
        }
        dim_edges[3].start = pos + diag_offset;
        
        // edge ends
        for (int j = 0; j < 4; j++) {
            dim_edges[j].end = dim_edges[j].start + main_dim_offset;
        }

        // add to cube_edges
        for (int j = 0; j < 4; j++) {
            cube_edges[i * 4 + j] = dim_edges[j];
        }
    }

    Edge edges_on_surface[12];
    int num_edges_intersected = 0;
    for (int i = 0; i < 12; i++) {
        Edge cube_edge = cube_edges[i];
        if (_IsoVals[threeDToOneD(cube_edge.start)] * _IsoVals[threeDToOneD(cube_edge.end)] < 0) {
            edges_on_surface[num_edges_intersected] = cube_edge;
            num_edges_intersected++;
        }
    }

    if (num_edges_intersected > 0) {
        float3 edge_intersections[12];
        for (int i = 0; i < num_edges_intersected; i++) {
            float3 edge_crossing = linInterpolate(edges_on_surface[i].end, edges_on_surface[i].start, _IsoVals[threeDToOneD(edges_on_surface[i].end)], _IsoVals[threeDToOneD(edges_on_surface[i].start)]);
            // // simple avg
            // float3 edge_crossing = (edges_on_surface[i].end - edges_on_surface[i].start) / 2.0 + edges_on_surface[i].start;
            edge_intersections[i] = edge_crossing;
        }

        float3 surface_point = float3(0.0, 0.0, 0.0);
        int count = 0;
        for (int i = 0; i < num_edges_intersected; i++) {
            surface_point += edge_intersections[i];
            count++;
        }
        surface_point /= float3(count, count, count);

        // if at least one edge intersection
        SetSurfacePoint(id, surface_point.zyx);
    } else {
        pos = transformToCenter(pos).zyx;
        _SurfacePoints[threeDToOneD(id)] = float4(pos, 0.0);
    }
    
    // SetSurfacePoint(id, pos);
}